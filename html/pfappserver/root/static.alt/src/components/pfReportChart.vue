/**
 * Component to draw plotly charts.
 * 
 * https://plot.ly/javascript/reference/
 * https://plot.ly/javascript/plotlyjs-function-reference/
 */
<template>
  <b-container fluid>
    <b-row class="mb-3" align-h="between" align-v="center">
      <b-col cols="auto" class="text-left" v-if="range">
        <b-form inline>
          <pf-form-datetime ref="datetimeStart" v-model="datetimeStart" :prepend-text="$t('Start')" class="mr-3" :disabled="isLoading"></pf-form-datetime>
          <pf-form-datetime ref="datetimeEnd" v-model="datetimeEnd" :prepend-text="$t('End')" class="mr-3" :disabled="isLoading"></pf-form-datetime>
          <b-input-group>
            <b-input-group-prepend is-text>
              {{ $t('Previous') }}
            </b-input-group-prepend>
            <b-button-group>
              <b-button variant="light" @click="setRangeByPeriod(60 * 30)">30m</b-button>
              <b-button variant="light" @click="setRangeByPeriod(60 * 60)">1h</b-button>
              <b-button variant="light" @click="setRangeByPeriod(60 * 60 * 6)">6h</b-button>
              <b-button variant="light" @click="setRangeByPeriod(60 * 60 * 12)">12h</b-button>
              <b-button variant="light" @click="setRangeByPeriod(60 * 60 * 24)">1D</b-button>
              <b-button variant="light" @click="setRangeByPeriod(60 * 60 * 24 * 7)">1W</b-button>
              <b-button variant="light" @click="setRangeByPeriod(60 * 60 * 24 * 14)">2W</b-button>
              <b-button variant="light" @click="setRangeByPeriod(60 * 60 * 24 * 28)">1M</b-button>
              <b-button variant="light" @click="setRangeByPeriod(60 * 60 * 24 * 28 * 2)">2M</b-button>
              <b-button variant="light" @click="setRangeByPeriod(60 * 60 * 24 * 28 * 6)">6M</b-button>
              <b-button variant="light" @click="setRangeByPeriod(60 * 60 * 24 * 365)">1Y</b-button>
            </b-button-group>
          </b-input-group>
        </b-form>
      </b-col>
      <b-col cols="auto" class="mr-auto"></b-col>
      <b-col cols="auto">
        <b-input-group :prepend="$t('Limit chart')" class="mr-3">
          <b-form-select class="pr-4" v-model="chartSizeLimit" :options="[5,10,25,50,100]" :disabled="isLoading" @input="onChartSizeChange" />
        </b-input-group>
      </b-col>
    </b-row>
    <b-row>
      <b-col cols="12">
        <div ref="plotly"></div>
      </b-col>
    </b-row>
  </b-container>
</template>

<script>
import Plotly from 'plotly.js'
import moment from 'moment'
import {
  pfReportChartColorsFull as colorsFull,
  pfReportChartColorsNull as colorsNull
} from '@/globals/pfReports'
import pfFormDatetime from '@/components/pfFormDatetime'

export default {
  name: 'pf-report-chart',
  components: {
    'pf-form-datetime': pfFormDatetime
  },
  props: {
    items: {
      type: Array
    },
    report: {
      type: Object
    },
    data: {
      type: Object
    },
    layout: {
      type: Object
    },
    options: {
      type: Object
    },
    range: {
      type: Boolean,
      default: false
    },
    isLoading: {
      type: Boolean,
      default: false
    },
    datetimeStart: {
      type: String
    },
    datetimeEnd: {
      type: String
    }
  },
  data () {
    return {
      chartSizeLimit: 25,
      emit: true
    }
  },
  computed: {
  },
  methods: {
    queueRender () {
      // buffer async calls to render
      if (this.timeoutRender) clearTimeout(this.timeoutRender)
      this.timeoutRender = setTimeout(this.render, 100)
    },
    render () {
      if (!this.$refs.plotly) return
      // dereference items, deep copy
      const itemsString = JSON.stringify(this.items)
      let values = this.report.chart.values(JSON.parse(itemsString))
      let labels = this.report.chart.labels(JSON.parse(itemsString))
      // dereference colors, deep copy
      let colors = JSON.parse(JSON.stringify(colorsFull))
      if (values.length === 0) {
        // no data
        colors = colorsNull
        values = [100]
        labels = [this.$i18n.t('No Data')]
      } else {
        // zip together then sort
        let zip = values.map((e, i) => [e, labels[i]]).sort((a, b) => (a[0] === b[0]) ? 0 : (a[0] > b[0]) ? -1 : 1)
        // truncate chart size limit
        if (zip.length > this.chartSizeLimit) {
          let other = zip.slice(this.chartSizeLimit).map(zip => zip[0])
          zip = zip.slice(0, this.chartSizeLimit)
          // push [sum(val), 'Other']
          zip.push([other.reduce((sum, val) => sum + val), this.$i18n.t('Other')])
          // "Paint It, Black" - Rolling Stones
          colors[this.chartSizeLimit] = '#000000'
          // unzip
          values = zip.map(zip => zip[0])
          labels = zip.map(zip => zip[1])
        }
      }
      let options = this.report.chart.options
      if (!options.marker) options.marker = {}
      options.marker = Object.assign(options.marker, { colors: colors })
      this.data = [Object.assign({
        values: values,
        labels: labels
      }, options)]
      Plotly.react(this.$refs.plotly, this.data, this.report.chart.layout, {displayModeBar: true, scrollZoom: true, displaylogo: false, showLink: false})
    },
    getWindowWidth (event) {
      const width = document.documentElement.clientWidth
      if (event && width !== this.windowWidth) {
        this.queueRender()
      }
      this.windowWidth = width
    },
    getWindowHeight (event) {
      const height = document.documentElement.clientHeight
      if (event && height !== this.windowHeight) {
        this.queueRender()
      }
      this.windowHeight = height
    },
    onChartSizeChange (chartSizeLimit) {
      this.chartSizeLimit = chartSizeLimit
      this.queueRender()
    },
    setRangeByPeriod (period) {
      const tsEnd = moment()
      const tsStart = tsEnd.subtract(period, 'seconds')
      // prevent emit, causes race condition when both start/end changed simultaneously
      this.emit = false
      this.datetimeEnd = tsEnd.format('YYYY-MM-DD HH:mm:ss')
      this.datetimeStart = tsStart.format('YYYY-MM-DD HH:mm:ss')
      this.emit = true
      // now send delayed emit(s) previosuly skipped
      this.$emit('changeDatetimeEnd', this.datetimeEnd)
      this.$emit('changeDatetimeStart', this.datetimeStart)
    }
  },
  mounted () {
    this.$nextTick(() => {
      window.addEventListener('resize', this.getWindowWidth)
      window.addEventListener('resize', this.getWindowHeight)
      this.getWindowWidth()
      this.getWindowHeight()
    })
  },
  created () {
  },
  watch: {
    items: {
      handler: function (a, b) {
        this.queueRender()
      },
      immediate: true,
      deep: true
    },
    report: {
      handler: function (a, b) {
        if (JSON.stringify(a) !== JSON.stringify(b)) {
          this.queueRender()
        }
      },
      immediate: true,
      deep: true
    },
    datetimeStart (a, b) {
      if (a !== b) {
        if (this.emit) this.$emit('changeDatetimeStart', a)
      }
    },
    datetimeEnd (a, b) {
      if (a !== b) {
        if (this.emit) this.$emit('changeDatetimeEnd', a)
      }
    }
  },
  beforeDestroy () {
    window.removeEventListener('resize', this.getWindowWidth)
    window.removeEventListener('resize', this.getWindowHeight)
  }
}
</script>

<style lang="scss">
/**
 * double-clicking legend causes user selection, disable
 */
.plotly * {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
</style>

